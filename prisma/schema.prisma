// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    // NOTE: When using mysql or sqlserver, uncomment the @db.Text annotations in model Account below
    // Further reading:
    // https://next-auth.js.org/adapters/prisma#create-the-prisma-schema
    // https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#string
    url      = env("DATABASE_URL")
}

model Post {
    id        Int      @id @default(autoincrement())
    name      String
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    createdBy   User   @relation(fields: [createdById], references: [id])
    createdById String

    @@index([name])
}

// Necessary for Next auth
model Account {
    id                       String  @id @default(cuid())
    userId                   String
    type                     String
    provider                 String
    providerAccountId        String
    refresh_token            String? // @db.Text
    access_token             String? // @db.Text
    expires_at               Int?
    token_type               String?
    scope                    String?
    id_token                 String? // @db.Text
    session_state            String?
    user                     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
    refresh_token_expires_in Int?

    @@unique([provider, providerAccountId])
}

model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
    id            String    @id @default(cuid())
    name          String?
    email         String?   @unique
    emailVerified DateTime?
    image         String?
    accounts      Account[]
    sessions      Session[]
    posts         Post[]
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}

// Main design model where we store all shapes we draw on the canvas
model Design {
    id     String  @id @default(cuid())
    name   String
    shapes Shape[]
}

// A shape is a polygon with an origin and a set of points
model Shape {
    id         String   @id @default(cuid())
    xPos       Float
    yPos       Float
    rotation   Float
    designId   String
    design     Design   @relation(fields: [designId], references: [id], onDelete: Cascade)

    // Points are allways ordered and on normalized coordinates. Position of shape is defined by xPos and yPos.
    points     Point[] 
    // When we defined some modification on edges we store them here
    edges      Edge[]
    // When we defined some modification on corners we store them here
    corners    Corner[]
    cutouts    Cutout[]

    // We have to remember where we started and ended drawing the shape because from there we can start reshaping the shape
    startEdgeId String?
    endEdgeId   String?
}

model Point {
    id      String  @id @default(cuid())
    xPos    Float
    yPos    Float
    shapeId String?
    shape   Shape?  @relation(fields: [shapeId], references: [id], onDelete: Cascade)
    corner  Corner?
}

// #########################################################
// IMPORTANT: Everything bellow this will be changed to match correct data model. We dont need it for now, Right now we only need to store points somewhere for demo
// #########################################################
model Edge {
    id                   String             @id @default(cuid())
    shapeId              String
    shape                Shape              @relation(fields: [shapeId], references: [id], onDelete: Cascade)
    point1Id             String
    point2Id             String
    linkedService        String?
    edgeShapes           EdgeShape[]
    backsplashConfig     BacksplashConfig?
    waterfallConfig      WaterfallConfig?
}

model EdgeShape {
    id             String @id @default(cuid())
    depth          Float
    width          Float
    type           String // "Right" | "Center" | "Left"
    edges          String // JSON array of "BumpIn" | "BumpOut"
    distance       Float
    sideAngleLeft  Float
    sideAngleRight Float
    edgeId         String
    edge           Edge   @relation(fields: [edgeId], references: [id], onDelete: Cascade)
}

model Corner {
    id                   String  @id @default(cuid())
    pointId              String  @unique
    point                Point   @relation(fields: [pointId], references: [id], onDelete: Cascade)
    cornerModification   String
    type                 String  // "Clip" | "BumpOut" | "None"
    clip                 Float?
    radius               Float
    bumpInLength         Float?
    bumpOutLength        Float?
    bumpOutDepth         Float?
    linkedService        String?
    shapeId              String
    shape                Shape   @relation(fields: [shapeId], references: [id], onDelete: Cascade)
}

model Cutout {
    id         String         @id @default(cuid())
    posX       Float
    posY       Float
    shapeId    String
    shape      Shape          @relation(fields: [shapeId], references: [id], onDelete: Cascade)
    configId   String         @unique
    config     CutoutConfig   @relation(fields: [configId], references: [id], onDelete: Cascade)
    templateId String?
    template   CutoutTemplate? @relation(fields: [templateId], references: [id])
}

model CutoutTemplate {
    id       String        @id @default(cuid())
    name     String
    configId String        @unique
    config   CutoutConfig  @relation(fields: [configId], references: [id], onDelete: Cascade)
    cutouts  Cutout[]
}

model CutoutConfig {
    id             String           @id @default(cuid())
    sinkType       String           // "Undermount" | "Drop-in" | "Oval" | "Double"
    shape          String           // "Rectangle" | "Oval" | "Double"
    length         Float
    width          Float
    holeCount      Int
    centerRules    String?          // TODO: JSON or separate model
    faucetRules    String?          // TODO: JSON or separate model
    productId      String
    product        Product          @relation(fields: [productId], references: [id])
    serviceId      String
    service        Service          @relation(fields: [serviceId], references: [id])
    cutout         Cutout?
    template       CutoutTemplate?
}

model BacksplashConfig {
    id         String   @id @default(cuid())
    serviceId  String
    service    Service  @relation(fields: [serviceId], references: [id])
    materialId String
    material   Material @relation(fields: [materialId], references: [id])
    height     Float
    edgeId     String   @unique
    edge       Edge     @relation(fields: [edgeId], references: [id], onDelete: Cascade)
}

model WaterfallConfig {
    id         String   @id @default(cuid())
    serviceId  String
    service    Service  @relation(fields: [serviceId], references: [id])
    materialId String
    material   Material @relation(fields: [materialId], references: [id])
    height     Float
    edgeId     String   @unique
    edge       Edge     @relation(fields: [edgeId], references: [id], onDelete: Cascade)
}

model Service {
    id                String             @id @default(cuid())
    name              String
    cutoutConfigs     CutoutConfig[]
    backsplashConfigs BacksplashConfig[]
    waterfallConfigs  WaterfallConfig[]
}

model Material {
    id                String             @id @default(cuid())
    name              String
    backsplashConfigs BacksplashConfig[]
    waterfallConfigs  WaterfallConfig[]
}

model Product {
    id            String         @id @default(cuid())
    name          String
    cutoutConfigs CutoutConfig[]
}
