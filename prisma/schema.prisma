// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    // NOTE: When using mysql or sqlserver, uncomment the @db.Text annotations in model Account below
    // Further reading:
    // https://next-auth.js.org/adapters/prisma#create-the-prisma-schema
    // https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#string
    url      = env("DATABASE_URL")
}

model Post {
    id        Int      @id @default(autoincrement())
    name      String
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    createdBy   User   @relation(fields: [createdById], references: [id])
    createdById String

    @@index([name])
}

// Necessary for Next auth
model Account {
    id                       String  @id @default(cuid())
    userId                   String
    type                     String
    provider                 String
    providerAccountId        String
    refresh_token            String? // @db.Text
    access_token             String? // @db.Text
    expires_at               Int?
    token_type               String?
    scope                    String?
    id_token                 String? // @db.Text
    session_state            String?
    user                     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
    refresh_token_expires_in Int?

    @@unique([provider, providerAccountId])
}

model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
    id            String    @id @default(cuid())
    name          String?
    email         String?   @unique
    emailVerified DateTime?
    image         String?
    accounts      Account[]
    sessions      Session[]
    posts         Post[]
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}

// Main design model where we store all shapes we draw on the canvas
model Design {
    id     String  @id @default(cuid())
    name   String
    shapes Shape[]
    texts  Text[]
}

// A shape is a polygon with an origin and a set of points
model Shape {
    id       String @id @default(cuid())
    xPos     Float
    yPos     Float
    rotation Float
    designId String
    design   Design @relation(fields: [designId], references: [id], onDelete: Cascade)

    // Points are allways ordered and on normalized coordinates. Position of shape is defined by xPos and yPos.
    points  Point[]
    // When we defined some modification on edges we store them here
    edges   Edge[]
    // When we defined some modification on corners we store them here
    corners Corner[]
    cutouts Cutout[]

    // We have to remember where we started and ended drawing the shape because from there we can start reshaping the shape
    startPoint1Id String?
    startPoint2Id String?
    endPoint1Id   String?
    endPoint2Id   String?
    startPoint1   Point?  @relation("ShapeStartPoint1", fields: [startPoint1Id], references: [id])
    startPoint2   Point?  @relation("ShapeStartPoint2", fields: [startPoint2Id], references: [id])
    endPoint1     Point?  @relation("ShapeEndPoint1", fields: [endPoint1Id], references: [id])
    endPoint2     Point?  @relation("ShapeEndPoint2", fields: [endPoint2Id], references: [id])

    materialId String?
    material   Material? @relation(fields: [materialId], references: [id])
}

model Point {
    id      String  @id @default(cuid())
    xPos    Float
    yPos    Float
    shapeId String?
    shape   Shape?  @relation(fields: [shapeId], references: [id], onDelete: Cascade)

    // When we define some modification on corner we store it here
    corner Corner?

    // Relations for edges that use this point
    edgesAsPoint1 Edge[] @relation("EdgePoint1")
    edgesAsPoint2 Edge[] @relation("EdgePoint2")

    // Relations for shapes start and end points that use this point
    shapeStart1 Shape[] @relation("ShapeStartPoint1")
    shapeStart2 Shape[] @relation("ShapeStartPoint2")
    shapeEnd1   Shape[] @relation("ShapeEndPoint1")
    shapeEnd2   Shape[] @relation("ShapeEndPoint2")
}

model Text {
    id              String  @id @default(cuid())
    xPos            Float
    yPos            Float
    text            String
    fontSize        Int
    isBold          Boolean
    isItalic        Boolean
    textColor       String
    backgroundColor String
    designId        String
    design          Design  @relation(fields: [designId], references: [id], onDelete: Cascade)
}

model Edge {
    id      String @id @default(cuid())
    shapeId String
    shape   Shape  @relation(fields: [shapeId], references: [id], onDelete: Cascade)

    // Edge is defined by two points for that we use point1Id and point2Id
    point1Id String
    point1   Point  @relation("EdgePoint1", fields: [point1Id], references: [id], onDelete: Cascade)
    point2Id String
    point2   Point  @relation("EdgePoint2", fields: [point2Id], references: [id], onDelete: Cascade)

    edgeModifications EdgeModification[]

    // TODO those configurations are not yet finished
    backsplashConfig BacksplashConfig?
    waterfallConfig  WaterfallConfig?
    linkedServiceId  String?
}

// Edge modifications are used to define the shape of the edge. (Bumps, curves, etc.). We need it as separate model because we can have up to 2 modifications on the single edge.
model EdgeModification {
    id       String               @id @default(cuid())
    edgeType EdgeModificationType @default(None)

    position EdgeShapePosition? @default(Center) // Optional because full curve type does not have position
    distance Float? // When position is Left or Right, we need to define distance from the corner

    // Used for bump ins and outs
    // ----------------------------
    depth          Float?
    width          Float?
    sideAngleLeft  Float? // Defines angle of the bump in the left side of the edge. This is not used when we have curve bumps
    sideAngleRight Float? // Defines angle of the bump in the right side of the edge. This is not used when we have curve bumps
    // ----------------------------

    fullRadiusDepth Float? // Used when full curve type is used to define depth of the curve

    edgeId String
    edge   Edge   @relation(fields: [edgeId], references: [id], onDelete: Cascade)
}

enum EdgeShapePosition {
    Right
    Center
    Left
}

enum EdgeModificationType {
    BumpIn
    BumpOut
    BumpInCurve
    BumpOutCurve
    FullCurve
    None
}

model Corner {
    id                 String     @id @default(cuid())
    type               CornerType @default(None)
    clip               Float? // Used when type is Clip to define length of the clip
    radius             Float? // Used when type is Radius to define radius of the corner
    modificationLength Float? // Used when type is BumpOut or Notch to define length of that modification
    modificationDepth  Float? // Used when type is BumpOut or Notch to define depth of that modification

    pointId String @unique
    point   Point  @relation(fields: [pointId], references: [id], onDelete: Cascade)
    shapeId String
    shape   Shape  @relation(fields: [shapeId], references: [id], onDelete: Cascade)

    // TODO: Define service relation
    linkedServiceId String?
}

enum CornerType {
    Clip
    Radius
    BumpOut
    Notch
    None
}

// TODO FINISH THIS when we start working on cutouts
model Cutout {
    id         String          @id @default(cuid())
    posX       Float
    posY       Float
    shapeId    String
    shape      Shape           @relation(fields: [shapeId], references: [id], onDelete: Cascade)
    configId   String          @unique
    config     CutoutConfig    @relation(fields: [configId], references: [id], onDelete: Cascade)
    templateId String?
    template   CutoutTemplate? @relation(fields: [templateId], references: [id])
}

model CutoutTemplate {
    id       String       @id @default(cuid())
    name     String
    configId String       @unique
    config   CutoutConfig @relation(fields: [configId], references: [id], onDelete: Cascade)
    cutouts  Cutout[]
}

model CutoutConfig {
    id          String          @id @default(cuid())
    sinkType    String // "Undermount" | "Drop-in" | "Oval" | "Double"
    shape       String // "Rectangle" | "Oval" | "Double"
    length      Float
    width       Float
    holeCount   Int
    centerRules String? // TODO: JSON or separate model
    faucetRules String? // TODO: JSON or separate model
    productId   String
    product     Product         @relation(fields: [productId], references: [id])
    serviceId   String
    service     Service         @relation(fields: [serviceId], references: [id])
    cutout      Cutout?
    template    CutoutTemplate?
}

model Service {
    id                String             @id @default(cuid())
    name              String
    cutoutConfigs     CutoutConfig[]
    backsplashConfigs BacksplashConfig[]
    waterfallConfigs  WaterfallConfig[]
}

model Material {
    id                String             @id @default(cuid())
    name              String
    img               String?
    SKU               String
    category          String
    subcategory       String
    shapes            Shape[]
    backsplashConfigs BacksplashConfig[]
    waterfallConfigs  WaterfallConfig[]
}

model Product {
    id            String         @id @default(cuid())
    name          String
    cutoutConfigs CutoutConfig[]
}

model BacksplashConfig {
    id         String   @id @default(cuid())
    serviceId  String
    service    Service  @relation(fields: [serviceId], references: [id])
    materialId String
    material   Material @relation(fields: [materialId], references: [id])
    height     Float
    edgeId     String   @unique
    edge       Edge     @relation(fields: [edgeId], references: [id], onDelete: Cascade)
}

model WaterfallConfig {
    id         String   @id @default(cuid())
    serviceId  String
    service    Service  @relation(fields: [serviceId], references: [id])
    materialId String
    material   Material @relation(fields: [materialId], references: [id])
    height     Float
    edgeId     String   @unique
    edge       Edge     @relation(fields: [edgeId], references: [id], onDelete: Cascade)
}
